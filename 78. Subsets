class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        subset = []
        def backtrack(i) :
            if i >= len(nums) :
                res.append(subset[:])
                return 
            # decision to include nums[i]
            subset.append(nums[i])
            backtrack(i+1)

            # decision not to include nums[i]
            subset.pop()
            backtrack(i+1)
        backtrack(0)
        return res

''' backtracking approach 
    time complexity : O(n * 2 ^ n)
    space complexity : O(n) - for recursion stack
'''

#####################################################################################################################################################################

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        N = len(nums)

        res = []
        for num in range(2 ** N):
            temp = []
            for i in range(N):
                if num & (1 << i):
                    temp.append(nums[i])
            res.append(temp[:])

        return res 

''' Bit Manipulation (Very Elegant)
    time complexity : O(n * 2 ^ n)
    space complexity : O(n)
'''

#####################################################################################################################################################################


class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = [[]]        
        for num in nums :
            res += [[num]+temp for temp in res]
        return res

''' Iterative (Build from Existing Subsets 
    time complexity : O(n * 2 ^ n)
    space complexity : O(1)
'''
