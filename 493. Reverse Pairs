class Solution:
    def reversePairs(self, arr: List[int]) -> int:
        res = []
        def mergesort(arr) :
            if len(arr) > 1 :
                left = arr[:len(arr)//2]
                right = arr[len(arr)//2:]
                mergesort(left)
                mergesort(right)

                i,j = 0,0
                while i < len(left) :
                    while j < len(right) and left[i] > 2 * right[j] :
                        j += 1
                    if j != 0 : res.append(j)
                    i += 1
                arr[:] = sorted(left+right)


        mergesort(arr)
        return sum(res)


''' solution with help of merge sort technique 
    time complexity : O(n logn)
    space complexity : O(n)
'''

###########################################

class Solution:
    def reversePairs(self, nums):
        self.count = 0
        self.mergeSort(nums, 0, len(nums) - 1)
        return self.count

    def mergeSort(self, nums, left, right):
        if left >= right:
            return

        mid = (left + right) // 2
        self.mergeSort(nums, left, mid)
        self.mergeSort(nums, mid + 1, right)

        # count reverse pairs
        j = mid + 1
        for i in range(left, mid + 1):
            while j <= right and nums[i] > 2 * nums[j]:
                j += 1
            self.count += (j - (mid + 1))

        # merge step
        self.merge(nums, left, mid, right)

    def merge(self, nums, left, mid, right):
        temp = []
        i, j = left, mid + 1

        while i <= mid and j <= right:
            if nums[i] <= nums[j]:
                temp.append(nums[i])
                i += 1
            else:
                temp.append(nums[j])
                j += 1

        temp.extend(nums[i:mid + 1])
        temp.extend(nums[j:right + 1])
        nums[left:right + 1] = temp

''' above solution instead of array slice used indices 
    time complexity : O(n logn)
    space complexity : O(n)
'''
