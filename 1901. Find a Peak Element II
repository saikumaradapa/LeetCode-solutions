class Solution:
    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
        n, m = len(mat), len(mat[0])
        l, r = 0, m - 1

        while l <= r:
            mid = (l + r) // 2
            row = self.max_row(mat, mid)

            val = mat[row][mid]
            left = mat[row][mid - 1] if mid > 0 else -1
            right = mat[row][mid + 1] if mid < m - 1 else -1

            if val > left and val > right:
                return [row, mid]
            elif left > val:
                r = mid - 1
            else:
                l = mid + 1

        return [-1, -1]  # Should never happen

    def max_row(self, mat, col):
        max_r = 0
        for i in range(len(mat)):
            if mat[i][col] > mat[max_r][col]:
                max_r = i
        return max_r


''' Binary search approach 
    time complexity : O(n * logm)
    space complexity : O(1)
'''

##################################################################################################################################################################################################################

class Solution:
    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
        def isPeak(i,j) :
            temp = mat[i][j]
            return  ((i== 0 or mat[i-1][j]<temp) and (j==0 or mat[i][j-1]<temp) and (i==(len(mat)-1) or mat[i+1][j]<temp) and ((j==len(mat[0])-1) or mat[i][j+1]<temp))
        for i in range(len(mat)) :
            for j in range(len(mat[0])) :
                print(i,j)
                if isPeak(i,j) : return [i,j]
        return -1

''' time complexity : O(n^2)
    space complexity : O(1)
'''
